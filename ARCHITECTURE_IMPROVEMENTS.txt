========================================
아키텍처 개선 제안
작성일: 2025-11-10 05:25
목적: 10시 회의 설명용
========================================

📊 현재 아키텍처 분석
========================================

문제점 1: Supervisor가 UC2/UC3를 직접 라우팅하지 않음
-----------------------------------------------------
현재 구조:
  START → Supervisor → UC1 → [UC1 내부에서 UC2/UC3 직접 호출] → END

코드 증거:
  - master_crawl_workflow.py:230-246
    "UC1은 내부적으로 UC2를 호출하므로, 실패하면 종료"

  - uc1_validation.py:590-612 (_trigger_uc2 함수)
    UC1이 UC2 Graph를 직접 invoke()

  - uc1_validation.py:465-545 (_trigger_uc3 함수)
    UC1이 UC3 Graph를 직접 invoke()

영향:
  ❌ Supervisor가 실제론 라우팅하지 않음 (껍데기만 존재)
  ❌ UC1이 Gateway 역할 (다른 UC들을 호출)
  ❌ 진정한 Multi-Agent Orchestration 아님
  ❌ LangSmith Trace에서 UC2/UC3가 Supervisor 경로로 보이지 않음


문제점 2: next_action 상태가 사용되지 않음
-----------------------------------------------------
현재:
  - UC1이 next_action = "heal" 또는 "uc3" 설정
  - 하지만 Supervisor는 이 값을 보지 않음
  - UC1 내부에서 바로 UC2/UC3 호출

개선 방향:
  - UC1이 next_action만 State에 설정
  - Supervisor가 next_action을 읽고 UC2/UC3로 라우팅
  - 각 UC는 Supervisor로 복귀


문제점 3: Test URL이 가상 URL임
-----------------------------------------------------
테스트 시나리오:
  - URL: "https://www.yna.co.kr/view/AKR20251110000001001"
  - 문제: 실제로 HTML fetch하지 않고 테스트 데이터 사용

영향:
  - UC2 Gemini 검증이 항상 실패 (실제 HTML 없음)
  - UC3 HTML 다운로드 404 에러


========================================
🎯 개선 방안 1: True Supervisor Routing
========================================

목표: Supervisor가 모든 라우팅 결정

변경 사항:
----------

1. UC1 → Supervisor 위임
   Before:
     UC1 internal code:
       if quality_score < 80:
           uc2_result = build_uc2_graph().invoke(state)

   After:
     UC1 returns:
       return {
           "next_action": "uc2",  # UC2 필요함을 알림
           "quality_score": 70,
           "quality_passed": False
       }


2. Supervisor 라우팅 로직 추가
   Before:
     if current_uc == "uc1":
         if uc1_result.get("quality_passed"):
             goto=END
         else:
             goto=END  # 항상 종료

   After:
     if current_uc == "uc1":
         if uc1_result.get("quality_passed"):
             goto=END
         elif uc1_result.get("next_action") == "heal":
             goto="uc2_self_heal"
         elif uc1_result.get("next_action") == "uc3":
             goto="uc3_new_site"


3. UC2/UC3 → Supervisor 복귀
   각 UC 마지막에:
     return {
         "next_action": "end",
         "uc2_consensus_result": {...}
     }

   Supervisor가 이를 받아서:
     if current_uc == "uc2":
         goto=END


========================================
🎯 개선 방안 2: 하이브리드 UC1
========================================

목표: 규칙 기반 + LLM 경계 케이스 처리

변경 사항:
----------

1. 규칙 기반 실행
   quality_score = calculate_quality_rule_based(state)

2. 경계 케이스 감지
   if 60 <= quality_score < 80:
       # 애매한 경우
       needs_llm_verification = True

   if "body_short" in missing_fields:
       # 본문이 200-500자 사이
       needs_llm_verification = True

3. LLM 재검증
   if needs_llm_verification:
       llm_score = calculate_quality_llm(state)
       final_score = llm_score  # LLM 우선


예상 효과:
---------
- 90% 케이스: 규칙 기반 (~100ms, $0)
- 10% 케이스: LLM 검증 추가 (~2초, $0.0003)
- 평균 속도: ~300ms (vs 2초)
- 정확도 향상: 불필요한 UC2 트리거 방지


========================================
🎯 개선 방안 3: Test Data 개선
========================================

문제: 가상 URL로 테스트 → UC2/UC3 실제 작동 안 함

해결책:
-------

1. Mock HTML 데이터 준비
   test_html_content = """
   <html>
       <head><title>한중 정상회담</title></head>
       <body>
           <h1 class="article-title">한중 정상회담 개최</h1>
           <div class="article-body">
               이재명 대통령이 10일 중국 시진핑 주석과...
           </div>
           <time class="publish-date">2025-11-10</time>
       </body>
   </html>
   """

2. State에 html_content 주입
   initial_state = {
       "url": test_url,
       "html_content": test_html_content,  # 추가
       "site_name": "yonhap"
   }

3. UC2 Gemini가 실제 HTML 검증 가능
   → Selector 제안이 실제로 작동하는지 확인


========================================
📈 우선순위 (회의 전 30분)
========================================

Priority 1: UC1 비교 결과 설명 준비 ✅
  - 이미 완료 (UC1_COMPARISON_RESULTS.txt)
  - 회의 설명 포인트 준비됨

Priority 2: Supervisor 라우팅 개선 제안 정리 ✅
  - 이 문서 (ARCHITECTURE_IMPROVEMENTS.txt)
  - 코드 라인 번호 + 개선 방향 명확

Priority 3: 구버전 Docs 정리 ⏳
  - docs/ 폴더 정리
  - 핵심 문서만 남기고 삭제


========================================
💡 회의 설명 스크립트
========================================

"현재 아키텍처의 핵심 이슈를 발견했습니다.

**문제:**
Supervisor가 실제론 UC2/UC3를 라우팅하지 않습니다.
UC1이 내부적으로 UC2/UC3를 직접 호출하고 있어서
진정한 Multi-Agent Orchestration이 아닙니다.

**증거:**
LangSmith Trace를 보면 항상 이 경로만 나옵니다:
  START → Supervisor → UC1 → Supervisor → END

UC2나 UC3가 Supervisor를 거치지 않고
UC1 내부 함수로 실행됩니다.

**개선 방향:**
1. UC1은 next_action만 State에 설정
2. Supervisor가 next_action을 보고 UC2/UC3로 라우팅
3. 각 UC는 작업 후 Supervisor로 복귀

이렇게 하면:
  START → Supervisor → UC1 → Supervisor → UC2 → Supervisor → END

진정한 자율 오케스트레이션이 됩니다.

**예상 작업 시간:** 2-3시간
**리스크:** 낮음 (State 구조는 그대로, 라우팅만 변경)

**추가로 UC1 비교 분석도 완료했습니다:**
규칙 기반 vs LLM 기반을 테스트한 결과,
하이브리드 접근이 최적입니다.
- 90% 케이스는 규칙 기반 (빠르고 무료)
- 10% 경계 케이스만 LLM 검증
- 평균 속도 300ms, 비용 90% 절감

자세한 내용은 UC1_COMPARISON_RESULTS.txt에 정리했습니다."


========================================
📝 코드 변경 예시 (참고용)
========================================

1. uc1_validation.py:decide_action_node()

   Before:
   ```python
   if quality_score < 80 and selector_exists:
       return {"next_action": "heal"}
       # 그 후 heal_or_discover_node가 UC2 직접 호출
   ```

   After:
   ```python
   if quality_score < 80 and selector_exists:
       return {
           "next_action": "heal",
           "quality_passed": False,
           "uc1_validation_result": {
               "quality_passed": False,
               "quality_score": quality_score,
               "next_action": "heal"
           }
       }
       # Supervisor로 복귀, Supervisor가 UC2 라우팅
   ```


2. master_crawl_workflow.py:supervisor_node()

   Add after line 246:
   ```python
   # UC1 failed, check next_action
   uc1_next = uc1_result.get("next_action")

   if uc1_next == "heal":
       logger.info("[Supervisor] UC1 → UC2 (heal)")
       return Command(
           update={
               "current_uc": "uc2",
               "workflow_history": history + ["supervisor → uc2_self_heal"]
           },
           goto="uc2_self_heal"
       )

   elif uc1_next == "uc3":
       logger.info("[Supervisor] UC1 → UC3 (discovery)")
       return Command(
           update={
               "current_uc": "uc3",
               "workflow_history": history + ["supervisor → uc3_new_site"]
           },
           goto="uc3_new_site"
       )
   ```


========================================
✅ 완료 항목
========================================

1. ✅ LLM 기반 UC1 구현 (uc1_validation_llm.py)
2. ✅ 비교 테스트 스크립트 (test_uc1_comparison.py)
3. ✅ 비교 결과 분석 (UC1_COMPARISON_RESULTS.txt)
4. ✅ 아키텍처 개선 제안 (이 문서)


========================================
⏳ 남은 작업
========================================

1. Docs 폴더 정리 (5분)
2. Supervisor 라우팅 구현 (회의 후, 2-3시간)
3. 하이브리드 UC1 구현 (회의 후, 1-2시간)
